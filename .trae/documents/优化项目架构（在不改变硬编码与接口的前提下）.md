## 目标与约束
- 目标：理顺分层、清晰职责、统一错误与日志、可扩展但不改现有行为。
- 约束：保留现有硬编码（如学号/密码、公钥、固定 URL 与 xkkz_id）和既有接口返回结构（code/msg/data）。

## 当前问题概览
- 业务与基础设施耦合：HTTP 会话、参数提取、搜索/选课逻辑分散在 `modules/*` 与 `functions/*`，跨模块耦合较多。
- 结果模型不统一：虽然使用了 `code/msg/data`，但各处键名与结构不完全一致，错误处理分散。
- 会话与重试策略分布：`CourseSniper` 负责重试，但 `CourseSelector.refresh_session` 与登录/参数提取的生命周期没有统一抽象。
- 交互流程分散：`main.py` 与 `test.py` 实现相似流程，存在重复。

## 分层架构设计
- Application 层（编排与 CLI）
  - 组合已有服务，提供用例级编排：登录→参数→搜索→添加→抢课；搜索→选课；课表→导出；状态分析。
  - 统一交互输入输出，保留原有硬编码的默认值。
- Domain 层（模型与契约）
  - 轻量数据模型：`Course`、`ScheduleItem`、`CourseParams`（dataclass/TypedDict），不改变现有字段名，仅提供类型约束。
  - 结果契约：`Result[T] = {code:int,msg:str,data:T}` 统一。
- Service 层（业务服务）
  - `LoginService`（封装 `LoginClient`）；`ParamService`；`SearchService`；`SelectService`；`ScheduleService`。
  - 保留原有请求路径与参数；对外暴露方法签名不改变（沿用现有字典参数）。
- Infrastructure 层（适配器与工具）
  - `SessionProvider`：集中管理 `requests.Session`、UA、Cookies、菜单初始化；供各服务复用。
  - `CryptoAdapter`（RSA 公钥加密，复用 `encrypt.py`）；`HtmlParser`（复用 `BeautifulSoup` 提取）。

## 模块映射与职责整理
- 复用现有文件，按层次引入薄封装：
  - `modules/login.py` → `LoginService`（包装调用，不改内部逻辑与 URL）。
  - `modules/tools/course_params_extractor.py` → `ParamService`。
  - `modules/course_searcher.py` → `SearchService`。
  - `modules/course_selector.py` → `SelectService`（保留硬编码 `xkkz_id`）。
  - `modules/schedule_extractor.py` → `ScheduleService`。
  - `functions/course_sniper.py` → 继续作为抢课用例执行器，注入 `SelectService` 与 `CourseStorage`。
  - `functions/course_storage.py`、`functions/utils.py`：保持不变，放入 Infrastructure 层使用。

## 统一结果与错误处理
- 结果规范：所有服务返回 `{code,msg,data}`；`code` 语义规范化（1000 成功，1001 业务失败，1003 超时，1006 会话失效，1007 格式错误，2333/2334 异常）。
- 错误源信息：在 `msg` 后附加简要上下文（接口名/状态码），但不改变现有行为。

## 会话生命周期
- `SessionProvider` 在登录成功后执行一次“菜单初始化”（现有逻辑），统一为各服务提供 `sess`。
- 在 `SelectService` 内部保留 `refresh_session`，并记录最近刷新时间，避免过度刷新（不改变现有刷新策略）。

## 日志与调试
- 统一通过 `init_logger(debug_flag)` 创建 logger；在服务层注入或模块级使用同一 logger。
- 保留现有日志级别与输出格式；补充关键路径的 debug 上下文（URL/Headers/Payload 的摘要）。

## 交互用例收敛
- 将 `main.py` 的菜单逻辑封装为 `AppOrchestrator`（模块内类/函数），用例方法：`run_assistant()`、`search_and_add()`、`start_sniping()`。
- `test.py` 使用同一 orchestrator 的精简方法（避免重复），但保留文件与流程结构。

## 数据模型（不改变字段）
- `Course`：保留 `kch_id/jxb_id/kcmc/jxbmc/...`；
- `CourseParams`：保留 `xkxnm/xkxqm/zyh_id/...`；
- `ScheduleItem`：保留现有 `schedule_extractor` 字段。
- 提供 TypedDict/dataclass 仅用于内部类型约束；外部接口仍返回 dict。

## 渐进式实施步骤
1. 引入 `SessionProvider`（内部复用 `requests.Session` 与菜单初始化），修改 `LoginClient` 初始化处按需使用；其余服务通过构造传入 `session`（不改现有签名）。
2. 提供轻量 `Result` 类型别名与返回规范检查（服务层内断言/包装），不改调用方解析逻辑。
3. 在 `modules/*` 顶部统一 logger 获取方式（调用 `init_logger` 或复用模块级 logger）。
4. 编写 `AppOrchestrator`（封装 `main.py` 的菜单用例），`test.py` 复用其搜索与选课方法；文件保留原名与入口。
5. 保持 `CourseSniper` 作为用例执行器，对其内部状态统计与退避日志做轻度整理（不改参数与行为）。
6. 统一错误码语义注释与少量消息格式化（不影响原有判断与分支）。
7. 回归测试：登录→提取→搜索→选课→抢课→课表→状态分析完整链路；验证日志产生与持久化文件写入。

## 风险与回滚
- 风险：会话注入路径变更可能导致服务拿不到 `sess`；
- 规避：在 `SessionProvider` 初始实现中只集中创建 `Session` 与激活菜单，不强制替换现有 `LoginClient.sess`；逐步接入。
- 回滚：保留现有文件入口与硬编码，不删除旧构造方式；问题时仅移除新封装并恢复直接使用 `requests.Session`。

## 交付物
- 重构后的分层结构（文件名基本不变），新增轻量 orchestrator 与 provider 封装
- 完整运行验证与 README 增补“架构与分层”说明（不影响现有使用方式）

请确认是否按上述计划推进实现；确认后我将开始逐步重构并验证，确保不改变既有硬编码与接口行为。